# 🎰 kotlin-lotto-precourse

## 🧾 로또 (Lotto)

### 📌 기능 요구 사항

간단한 로또 발매기를 구현한다.

- 로또 번호의 범위는 1~45이다.
- 1개의 로또는 중복되지 않는 6개의 숫자로 구성된다.
- 당첨 번호는 6개 번호 + 보너스 번호 1개를 입력받는다.
- 구입 금액은 1,000원 단위로 입력받으며, 금액에 따라 로또를 자동 발행한다.
- 당첨 기준과 상금은 다음과 같다.

| 등수 | 조건 | 상금 |
|:--:|:--|--:|
| 1등 | 6개 번호 일치 | 2,000,000,000원 |
| 2등 | 5개 번호 + 보너스 번호 일치 | 30,000,000원 |
| 3등 | 5개 번호 일치 | 1,500,000원 |
| 4등 | 4개 번호 일치 | 50,000원 |
| 5등 | 3개 번호 일치 | 5,000원 |

- 결과로 당첨 내역 및 총 수익률을 출력한다.
- 잘못된 입력 시 `IllegalArgumentException`을 발생시키며, 예외 메시지는 반드시 `"[ERROR]"`로 시작해야 한다.

---

## 🧱 구현 단계

### Step 1️⃣. 입력 처리 (InputView)

**로또 구입 금액 입력**
- [ ] 공백 입력 시 예외 처리
- [ ] 숫자가 아닌 값 입력 시 예외 처리
- [ ] 0 또는 음수 입력 시 예외 처리
- [ ] 1000원 단위로 나누어 떨어지지 않으면 예외 처리

**당첨 번호 입력**
- [ ] 쉼표(,)를 기준으로 구분
- [ ] 중복된 숫자 입력 시 예외 처리
- [ ] 숫자가 아닌 값 입력 시 예외 처리
- [ ] 1~45 범위를 벗어나면 예외 처리

**보너스 번호 입력**
- [ ] 공백 입력 시 예외 처리
- [ ] 숫자가 아닌 값 입력 시 예외 처리
- [ ] 1~45 범위를 벗어나면 예외 처리
- [ ] 당첨 번호와 중복 시 예외 처리

---

### Step 2️⃣. 로또 생성 (LottoGenerator)

- [ ] 구입 금액을 1000으로 나눈 개수만큼 로또를 발행
- [ ] `Randoms.pickUniqueNumbersInRange(1, 45, 6)`을 이용해 중복 없는 6개의 숫자 생성
- [ ] 오름차순 정렬
- [ ] 생성된 로또를 `Lotto` 객체 리스트로 관리

---

### Step 3️⃣. 당첨 검증 로직 (Validator)

- [ ] 각 로또 번호와 당첨 번호를 비교해 일치 개수 계산
- [ ] 보너스 번호 포함 여부 확인
- [ ] 일치 개수와 보너스 번호 결과를 `Rank` enum으로 변환

---

### Step 4️⃣. 등수 관리 (Rank enum)

- [ ] `Rank` enum을 통해 등수별 상금, 조건 관리
- [ ] `from(matchCount, bonusMatched)` 함수로 등수 판별 자동화
- [ ] 1~5등 외의 경우 `MISS` 처리

---

### Step 5️⃣. 출력 처리 (OutputView)

**구매한 로또 수량 및 번호를 출력**

```
8개를 구매했습니다.
[8, 21, 23, 41, 42, 43]
[3, 5, 11, 16, 32, 38]
[7, 11, 16, 35, 36, 44]
[1, 8, 11, 31, 41, 42]
[13, 14, 16, 38, 42, 45]
[7, 11, 30, 40, 42, 43]
[2, 13, 22, 32, 38, 45]
[1, 3, 5, 14, 22, 45]
```

**당첨 통계 출력**

```
당첨 통계
---
3개 일치 (5,000원) - 1개
4개 일치 (50,000원) - 0개
5개 일치 (1,500,000원) - 0개
5개 일치, 보너스 볼 일치 (30,000,000원) - 0개
6개 일치 (2,000,000,000원) - 0개
총 수익률은 62.5%입니다.
```

---

### Step 6️⃣. 수익률 계산

- [ ] `Rank`별 상금 합계 계산 (`sumOf`)
- [ ] `총 수익률 = (총 상금 / 총 구입금액) × 100`
- [ ] 소수점 첫째 자리까지 반올림하여 출력

---

### Step 7️⃣. 예외 처리

- [ ] 입력값 오류 시 `IllegalArgumentException` 발생
- [ ] 예외 메시지는 `"[ERROR]"`로 시작
- [ ] 예외 발생 시 해당 입력 단계부터 재입력

---

### Step 8️⃣. 테스트 코드 작성

- [ ] `LottoTest`: 로또 번호 생성 및 검증 테스트
- [ ] `ValidatorTest`: 일치 개수 및 등수 계산 테스트
- [ ] `InputViewTest`: 입력값 검증 테스트
- [ ] `OutputViewTest`: 출력 포맷 및 수익률 계산 테스트
- [ ] 모든 테스트 통과 (`./gradlew clean test`)

---

## 🗂️ 패키지 구조 (예시)

```
└── lotto
    ├── controller
    │   └── LottoController.kt
    ├── view
    │   ├── InputView.kt
    │   └── OutputView.kt
    ├── model
    │   ├── Lotto.kt
    │   ├── WinningLotto.kt
    │   └── LottoResult.kt
    ├── domain
    │   ├── LottoGenerator.kt
    │   └── Rank.kt
    ├── util
    │   └── Validator.kt
    └── Application.kt
```

---

## 🧪 실행 및 테스트

```bash
# 테스트 실행
./gradlew clean test

# 또는 IDE에서 Application.kt 실행
```

---

## 🖨️ 출력 예시

```
구입금액을 입력해 주세요.
8000

8개를 구매했습니다.
[8, 21, 23, 41, 42, 43]
[3, 5, 11, 16, 32, 38]
[7, 11, 16, 35, 36, 44]
[1, 8, 11, 31, 41, 42]
[13, 14, 16, 38, 42, 45]
[7, 11, 30, 40, 42, 43]
[2, 13, 22, 32, 38, 45]
[1, 3, 5, 14, 22, 45]

당첨 번호를 입력해 주세요.
1,2,3,4,5,6

보너스 번호를 입력해 주세요.
7

당첨 통계
---
3개 일치 (5,000원) - 1개
4개 일치 (50,000원) - 0개
5개 일치 (1,500,000원) - 0개
5개 일치, 보너스 볼 일치 (30,000,000원) - 0개
6개 일치 (2,000,000,000원) - 0개
총 수익률은 62.5%입니다.
```

---

## 🚨 예외 처리 규칙

- 모든 에러 메시지는 **`[ERROR]`로 시작**해야 함
- `IllegalArgumentException`, `IllegalStateException` 등 명확한 예외 타입 사용
- 예외 발생 시 해당 입력 단계부터 재입력

---

## 🧰 사용 라이브러리

| 라이브러리 | 기능 |
|:--|:--|
| `camp.nextstep.edu.missionutils.Randoms` | `Randoms.pickUniqueNumbersInRange(1, 45, 6)` 사용 |
| `camp.nextstep.edu.missionutils.Console` | `Console.readLine()` 사용 |

---

## ✅ 프로그래밍 요구 사항

- Kotlin **2.2.0**
- 함수 길이 **15라인 이하**
- indent depth **2 이하**
- `else` 대신 **조건부 return** 활용
- `System.exit()`, `exitProcess()` **사용 금지**
- `build.gradle.kts` 수정 **금지**
- UI 로직(`System.out`, `System.in`)은 단위 테스트 **제외**

---

## ✍️ 커밋 컨벤션 (Angular Style)

```
feat: 입력값 검증 로직 추가 (InputView)
fix: 로또 번호 중복 처리 버그 수정
refactor: Rank enum 도입 및 수익률 계산 단순화
docs: README 기능 목록 추가
test: LottoTest 중복/범위 케이스 보강
```

---

## 💬 프로젝트 회고

### 가장 오래 걸린 부분
`Rank` Enum을 적용해 일치 개수와 보너스 여부를 매핑하는 리팩토링 과정. 기존의 if-else 구조를 제거하고 enum을 활용해 등수 판단 로직을 단순화하는 데 많은 시간이 걸렸습니다.

### 배운 점
Enum과 data class를 함께 사용하면 코드 가독성과 유지보수성이 크게 향상됨을 체감했습니다. 또한 단위 테스트를 활용해 작은 단위별 동작을 검증하면서 점진적으로 코드를 완성하는 방식을 익혔습니다.

### 리팩토링 이후 개선점
각 클래스의 책임이 명확히 분리되면서 `Validator`, `Rank`, `OutputView` 간의 결합도가 낮아졌고, 테스트 커버리지가 높아져 전체 구조가 안정적으로 동작함을 확인했습니다.
